"""
Interactive Verification Pipeline (Improved)

Features:
- Robust batch processing with incremental saving
- Keyboard shortcuts for faster review
- Uses Native DICOM orientation (Y, X, Z) to avoid reorientation errors
- Detailed CSV reporting

Usage:
    python verify_pipeline_improved.py --input-dir /path/to/patients --output-csv validation_results.csv
"""

import argparse
import logging
from pathlib import Path
from typing import Dict, Tuple

import matplotlib
import matplotlib.pyplot as plt
import nibabel as nib
import numpy as np
import pandas as pd
import pydicom
from matplotlib.widgets import Button, Slider
from nibabel.processing import resample_from_to

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Import project modules
from src.patient_manager import get_patient_metadata
from src.pipeline import find_patient_folders, process_single_patient

# We use our own loader to ensure consistency with the pipeline's orientation assumptions
from verify_segmentation import load_segmentation_mask

# --- Configuration ---

VERTEBRAE_COLORS = {
    'vertebrae_T11': '#800080',  # Purple
    'vertebrae_T12': '#FFC0CB',  # Pink
    'vertebrae_L1': '#FF0000',  # Red
    'vertebrae_L2': '#FF8C00',  # Dark Orange
    'vertebrae_L3': '#FFD700',  # Gold
    'vertebrae_L4': '#00FF00',  # Lime
    'vertebrae_L5': '#0000FF',  # Blue
    'vertebrae_T11_body': '#4B0082',  # Indigo
    'vertebrae_T12_body': '#DB7093',  # Pale Violet Red
    'vertebrae_L1_body': '#800000',  # Dark Red
    'vertebrae_L2_body': '#8B4500',  # Saddle Brown
    'vertebrae_L3_body': '#B8860B',  # Dark Goldenrod
    'vertebrae_L4_body': '#006400',  # Dark Green
    'vertebrae_L5_body': '#00008B',  # Dark Blue
}

LUMBAR_VERTEBRAE = ['vertebrae_T11', 'vertebrae_T12', 'vertebrae_L1', 'vertebrae_L2', 'vertebrae_L3', 'vertebrae_L4', 'vertebrae_L5']
LUMBAR_BODIES = [f"{v}_body" for v in LUMBAR_VERTEBRAE]

# --- Helper Functions ---

def force_backend():
    """Configure Matplotlib backend to ensure interactive mode works."""
    backends_to_try = ['TkAgg', 'Qt5Agg', 'Qt4Agg']
    for backend in backends_to_try:
        try:
            matplotlib.use(backend, force=True)
            logger.info(f"Using matplotlib backend: {backend}")
            return
        except (ImportError, ValueError):
            continue
    logger.warning("Could not force a specific interactive backend. Using default.")

def load_dicom_native(dicom_folder: Path) -> Tuple[np.ndarray, nib.Nifti1Image]:
    """
    Load DICOM series keeping the native (Rows, Cols, Slices) layout.
    Uses a simple affine to match the pipeline's behavior (dicom_processor.py).
    
    Returns:
        volume: (Rows/Y, Cols/X, Slices/Z)
        nifti_img: Nifti object with simple affine
    """
    dicom_files = sorted(list(dicom_folder.glob("*.dcm")) + list(dicom_folder.glob("*.DCM")))
    if not dicom_files:
        raise ValueError("No DICOM files found")
        
    # Read all files
    slices = [pydicom.dcmread(str(f)) for f in dicom_files]
    
    # Sort by Z position
    try:
        slices.sort(key=lambda x: float(x.ImagePositionPatient[2]))
    except:
        slices.sort(key=lambda x: x.InstanceNumber)
        
    # Stack
    ref = slices[0]
    rows, cols = ref.Rows, ref.Columns
    vol = np.zeros((rows, cols, len(slices)), dtype=np.float32)
    
    for i, s in enumerate(slices):
        data = s.pixel_array.astype(np.float32)
        if hasattr(s, 'RescaleSlope'):
            data = data * s.RescaleSlope + s.RescaleIntercept
        vol[:, :, i] = data
        
    # Construct Simple Affine (matching src/dicom_processor.py)
    # Note: The pipeline uses a simplified affine that maps dim 0 to Z spacing in the affine diagonal...
    # But let's check exactly what dicom_processor.py does:
    # affine[0,0] = spacing[2] (Z spacing??) -> Assigned to X axis?
    # This suggests the pipeline produces Weird Affines.
    # We must match it to align with masks generated by that pipeline.
    
    ps = ref.PixelSpacing
    st = ref.SliceThickness
    spacing = [float(st), float(ps[0]), float(ps[1])] # (Z, Y, X) based on dicom_processor logic
    
    origin = ref.ImagePositionPatient
    
    affine = np.eye(4)
    # Matching src/dicom_processor.py logic exactly:
    affine[0, 0] = spacing[2] # X spacing (ps[1])
    affine[1, 1] = spacing[1] # Y spacing (ps[0])
    affine[2, 2] = spacing[0] # Z spacing (st)
    
    if origin:
        affine[0, 3] = origin[0]
        affine[1, 3] = origin[1]
        affine[2, 3] = origin[2]
        
    return vol, nib.Nifti1Image(vol, affine)

def load_and_align_data(dicom_folder: Path, segmentation_dir: Path) -> Tuple[np.ndarray, Dict[str, np.ndarray], nib.Nifti1Image]:
    """
    Load CT and masks in native space.
    """
    # 1. Load CT
    logger.info("Loading CT (Native)...")
    ct_volume, ct_img = load_dicom_native(dicom_folder)
    
    # 2. Load Masks
    masks = {}
    ct_shape = ct_volume.shape
    
    def process_mask(path, name):
        if not path.exists(): return
        try:
            mask_img = load_segmentation_mask(path)
            # Resample to match CT if needed (handles affine mismatch)
            if mask_img.shape != ct_shape or not np.allclose(mask_img.affine, ct_img.affine):
                logger.info(f"Resampling {name}...")
                mask_img = resample_from_to(mask_img, ct_img, order=0)
            masks[name] = mask_img.get_fdata()
        except Exception as e:
            logger.warning(f"Failed to load {name}: {e}")

    for v in LUMBAR_BODIES:
        process_mask(segmentation_dir / f"{v}.nii.gz", v)
        
    if not masks:
        process_mask(segmentation_dir / "vertebrae_body.nii.gz", 'vertebrae_body')

    return ct_volume, masks, ct_img

# --- Viewer Class ---

class VerificationViewer:
    """Interactive viewer for verification (Native Space)."""
    
    def __init__(self, ct_volume, masks, patient_id, exam_date=None, window_level=40, window_width=400):
        self.ct_volume = ct_volume # (Y, X, Z)
        self.masks = masks
        self.patient_id = patient_id
        self.exam_date = exam_date
        self.window_level = window_level
        self.window_width = window_width
        
        self.shape = ct_volume.shape
        # Z is Dim 2 (Slices)
        self.slice_z = self.shape[2] // 2 
        # X is Dim 1 (Columns) -> Sagittal Plane
        self.slice_x = self.shape[1] // 2 
        
        self.selected_slices = []
        self.is_successful = None
        self.show_selected = True
        self.fig = None
        
    def window_ct(self, slice_data):
        mn = self.window_level - self.window_width / 2
        mx = self.window_level + self.window_width / 2
        return np.clip((slice_data - mn) / (mx - mn), 0, 1)

    def calculate_average_hu(self):
        if not self.selected_slices: return 0.0
        values = []
        for z in self.selected_slices:
            if 0 <= z < self.shape[2]:
                slice_data = self.ct_volume[:, :, z]
                mask_total = np.zeros_like(slice_data, dtype=bool)
                for m in self.masks.values():
                    mask_total |= (m[:, :, z] > 0.5)
                if np.any(mask_total):
                    values.extend(slice_data[mask_total])
        return float(np.mean(values)) if values else 0.0

    def on_key_press(self, event):
        if event.key == 'y': self.mark_success(None)
        elif event.key == 'n': self.mark_fail(None)
        elif event.key == 's': self.toggle_slice_selection(None)
        elif event.key in ['enter', 'q']: plt.close(self.fig)
        elif event.key == 'right': self.slider_z.set_val(min(self.shape[2]-1, self.slice_z + 1))
        elif event.key == 'left': self.slider_z.set_val(max(0, self.slice_z - 1))
        elif event.key == 'up': self.slider_x.set_val(min(self.shape[1]-1, self.slice_x + 1))
        elif event.key == 'down': self.slider_x.set_val(max(0, self.slice_x - 1))

    def update_axial(self, val):
        """Update Axial View (XY Plane at fixed Z)."""
        z = int(val)
        self.slice_z = z
        self.ax_axial.clear()
        
        # Data: (Y, X). Y=Rows(0=Top=Ant), X=Cols(0=Left=Right).
        # Matplotlib origin='upper' puts Row 0 at Top.
        # This matches standard display if Y=0 is Anterior.
        # And X=0 is Patient Right (Screen Left).
        
        ct_slice = self.ct_volume[:, :, z]
        ct_disp = self.window_ct(ct_slice)
        
        self.ax_axial.imshow(ct_disp, cmap='gray', origin='upper')
        
        for name, mask in self.masks.items():
            m_slice = mask[:, :, z]
            if np.any(m_slice):
                color = VERTEBRAE_COLORS.get(name, '#FF00FF')
                c = [int(color[1:3], 16)/255, int(color[3:5], 16)/255, int(color[5:7], 16)/255]
                
                overlay = np.zeros((*m_slice.shape, 4))
                overlay[m_slice > 0] = [*c, 0.4]
                
                self.ax_axial.imshow(overlay, origin='upper')
                self.ax_axial.contour(m_slice, levels=[0.5], colors=[color], linewidths=2, alpha=0.8)

        if self.show_selected and z in self.selected_slices:
             self.ax_axial.text(0.05, 0.95, "SELECTED", transform=self.ax_axial.transAxes, 
                                color='yellow', weight='bold', fontsize=14,
                                bbox=dict(facecolor='black', alpha=0.5))

        self.ax_axial.set_title(f"Axial (Z={z})\n(R | L)", color='yellow' if z in self.selected_slices else 'black')
        self.ax_axial.axis('off')
        
        if hasattr(self, 'ax_sagittal'):
            self.update_sagittal(self.slice_x)

    def update_sagittal(self, val):
        """Update Sagittal View (YZ Plane at fixed X)."""
        x = int(val)
        self.slice_x = x
        self.ax_sagittal.clear()
        
        # Data: Volume is (Y, X, Z).
        # Slice at X -> (Y, Z). (Ant-Post, Inf-Sup).
        # We want Z on vertical (Rows). Y on horizontal (Cols).
        # Transpose -> (Z, Y).
        # origin='lower' -> Row 0 (Inf) at Bottom. Row N (Sup) at Top. Correct.
        # Cols (Y): 0 (Ant) at Left. N (Post) at Right. Correct.
        
        ct_slice = self.ct_volume[:, x, :] # (Y, Z)
        ct_disp = self.window_ct(ct_slice).T # (Z, Y)
        
        self.ax_sagittal.imshow(ct_disp, cmap='gray', origin='lower', aspect='auto')
        
        for name, mask in self.masks.items():
            m_slice = mask[:, x, :]
            if np.any(m_slice):
                color = VERTEBRAE_COLORS.get(name, '#FF00FF')
                c = [int(color[1:3], 16)/255, int(color[3:5], 16)/255, int(color[5:7], 16)/255]
                
                m_disp = m_slice.T
                overlay = np.zeros((*m_disp.shape, 4))
                overlay[m_disp > 0] = [*c, 0.4]
                
                self.ax_sagittal.imshow(overlay, origin='lower', aspect='auto')
                self.ax_sagittal.contour(m_disp, levels=[0.5], colors=[color], linewidths=2)
        
        # Ref line (Z slice)
        self.ax_sagittal.axhline(y=self.slice_z, color='cyan', linestyle='--', alpha=0.7)
        self.ax_sagittal.set_title(f"Sagittal (X={x})\n(Ant | Post)")
        self.ax_sagittal.axis('off')
        self.fig.canvas.draw_idle()

    def toggle_slice_selection(self, event):
        if self.slice_z in self.selected_slices:
            self.selected_slices.remove(self.slice_z)
        else:
            self.selected_slices.append(self.slice_z)
            self.selected_slices.sort()
        self.update_axial(self.slice_z)
        self.update_info()

    def mark_success(self, event):
        self.is_successful = True
        self.update_info()

    def mark_fail(self, event):
        self.is_successful = False
        self.update_info()

    def update_info(self):
        status = "SUCCESS" if self.is_successful else ("FAILED" if self.is_successful is False else "PENDING")
        color = 'green' if self.is_successful else ('red' if self.is_successful is False else 'gray')
        avg_hu = self.calculate_average_hu()
        
        txt = (f"Patient: {self.patient_id}\n"
               f"Status: {status}\n"
               f"Selected Slices: {len(self.selected_slices)}\n"
               f"Avg HU: {avg_hu:.1f}")
        
        self.info_text.set_text(txt)
        self.info_text.set_color(color)
        self.fig.canvas.draw_idle()

    def show(self):
        force_backend()
        self.fig = plt.figure(figsize=(16, 9))
        self.fig.canvas.mpl_connect('key_press_event', self.on_key_press)
        
        self.ax_axial = plt.subplot(1, 2, 1)
        self.ax_sagittal = plt.subplot(1, 2, 2)
        plt.subplots_adjust(bottom=0.2)
        
        self.info_text = self.fig.text(0.02, 0.1, "", fontsize=12, fontfamily='monospace', weight='bold')
        
        ax_sz = plt.axes([0.25, 0.1, 0.3, 0.03])
        ax_sx = plt.axes([0.65, 0.1, 0.3, 0.03])
        
        self.slider_z = Slider(ax_sz, 'Axial Z', 0, self.shape[2]-1, valinit=self.slice_z, valstep=1)
        self.slider_x = Slider(ax_sx, 'Sagittal X', 0, self.shape[1]-1, valinit=self.slice_x, valstep=1)
        
        self.slider_z.on_changed(self.update_axial)
        self.slider_x.on_changed(self.update_sagittal)
        
        ax_btn_y = plt.axes([0.25, 0.05, 0.1, 0.04])
        ax_btn_n = plt.axes([0.36, 0.05, 0.1, 0.04])
        ax_btn_s = plt.axes([0.47, 0.05, 0.15, 0.04])
        ax_btn_d = plt.axes([0.65, 0.05, 0.2, 0.04])
        
        self.btn_y = Button(ax_btn_y, 'Success (y)')
        self.btn_n = Button(ax_btn_n, 'Fail (n)')
        self.btn_s = Button(ax_btn_s, 'Select Slice (s)')
        self.btn_d = Button(ax_btn_d, 'Done (Enter)')
        
        self.btn_y.on_clicked(self.mark_success)
        self.btn_n.on_clicked(self.mark_fail)
        self.btn_s.on_clicked(self.toggle_slice_selection)
        self.btn_d.on_clicked(lambda x: plt.close(self.fig))
        
        self.update_axial(self.slice_z)
        self.update_info()
        plt.show()
        
        return {
            'patient_id': self.patient_id,
            'exam_date': self.exam_date,
            'is_successful': self.is_successful,
            'selected_slices': self.selected_slices,
            'average_hu': self.calculate_average_hu()
        }

# --- Main Pipeline Logic ---

def load_existing_results(csv_path: Path) -> pd.DataFrame:
    if csv_path.exists():
        return pd.read_csv(csv_path)
    return pd.DataFrame(columns=['Patient ID', 'Exam Date', 'Status', 'Selected Slice Numbers', 'Average HU'])

def append_result(csv_path: Path, result: Dict):
    df_new = pd.DataFrame([{
        'Patient ID': result['patient_id'],
        'Exam Date': result.get('exam_date', ''),
        'Status': 'Success' if result['is_successful'] else ('Failed' if result['is_successful'] is False else 'Skipped'),
        'Selected Slice Numbers': ','.join(map(str, result['selected_slices'])),
        'Average HU': f"{result['average_hu']:.2f}" if result['average_hu'] is not None else ''
    }])
    if csv_path.exists():
        df_new.to_csv(csv_path, mode='a', header=False, index=False)
    else:
        df_new.to_csv(csv_path, index=False)

def run_pipeline(input_dir: Path, output_csv: Path, output_base_dir: Path, fast: bool, device: str, force: bool = False):
    patient_folders = find_patient_folders(input_dir)
    if not patient_folders:
        logger.error("No patients found.")
        return

    logger.info(f"Found {len(patient_folders)} patients.")
    existing_df = load_existing_results(output_csv)
    processed_ids = set(existing_df['Patient ID'].astype(str).unique()) if not existing_df.empty else set()
    
    for i, folder in enumerate(patient_folders, 1):
        meta = get_patient_metadata(folder)
        pid = meta.get('patient_id') or folder.name
        if pid in processed_ids and not force:
            logger.info(f"[{i}/{len(patient_folders)}] Skipping {pid}")
            continue
            
        logger.info(f"[{i}/{len(patient_folders)}] Processing {pid}...")
        try:
            # Simple check for existing segmentation
            from src.patient_manager import create_patient_output_dir
            p_out = create_patient_output_dir(output_base_dir, pid)
            seg_dir = p_out / 'segmentations'
            
            if not (seg_dir / 'vertebrae_L1.nii.gz').exists() and not (seg_dir / 'vertebrae_body.nii.gz').exists() and not (seg_dir / 'vertebrae_L1_body.nii.gz').exists():
                process_single_patient(folder, output_base_dir, fast_segmentation=fast, device=device)
            
            ct, masks, _ = load_and_align_data(folder, seg_dir)
            if not masks:
                logger.warning("No masks found!")
                res = {'patient_id': pid, 'exam_date': meta.get('study_date'), 'is_successful': False, 'selected_slices': [], 'average_hu': 0}
            else:
                viewer = VerificationViewer(ct, masks, pid, meta.get('study_date'))
                res = viewer.show()
            append_result(output_csv, res)
        except Exception as e:
            logger.error(f"Error processing {pid}: {e}", exc_info=True)

def main():
    parser = argparse.ArgumentParser(description="Improved Verification Pipeline")
    parser.add_argument('--input-dir', required=True, type=Path)
    parser.add_argument('--output-csv', required=True, type=Path)
    parser.add_argument('--output-base-dir', type=Path, default=Path('verification_output'))
    parser.add_argument('--fast', action='store_true')
    parser.add_argument('--device', default='gpu', choices=['gpu', 'cpu'])
    parser.add_argument('--force', action='store_true')
    args = parser.parse_args()
    run_pipeline(args.input_dir, args.output_csv, args.output_base_dir, args.fast, args.device, args.force)

if __name__ == '__main__':
    main()
